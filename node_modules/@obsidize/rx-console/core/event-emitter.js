import { isFunction } from './utility';
/**
 * Generalized, minimal implementation of a container that
 * holds callbacks, and can emit values to them.
 *
 * This implementation does not accept "named" events like `emitter.on('error', function (err) {...})`,
 * and as a consequence is drastically more simple / compact / efficient than other event emitter implementations.
 *
 * In general, rather than smashing multiple "named" events onto one emitter,
 * just make multiple emitter instances instead.
 *
 * For Example:
 * - `emitter.on('next', ...)` -> onNext: EventEmitter<T>;
 * - `emitter.on('done', ...)` -> onDone: EventEmitter<T>;
 * - `emitter.on('error', ...)` -> onError: EventEmitter<any>;
 */
export class EventEmitter {
    constructor() {
        this.mListeners = [];
    }
    get listenerCount() {
        return this.mListeners.length;
    }
    emit(value) {
        for (const listener of this.mListeners)
            listener(value);
    }
    hasListener(listener) {
        return this.mListeners.indexOf(listener) >= 0;
    }
    addListener(listener) {
        if (isFunction(listener) && !this.hasListener(listener))
            this.mListeners.push(listener);
        return this;
    }
    removeListener(listener) {
        const index = this.mListeners.indexOf(listener);
        if (index >= 0)
            this.mListeners.splice(index, 1);
        return this;
    }
    removeAllListeners() {
        while (this.mListeners.length > 0)
            this.mListeners.pop();
        return this;
    }
    /**
     * Transform this instance into an observable stream, using the given
     * generator function.
     *
     * This caters mainly towards the fromEventPattern creator function
     * provided by RxJS.
     */
    asObservable(generator) {
        return generator(listener => this.addListener(listener), listener => this.removeListener(listener));
    }
}
