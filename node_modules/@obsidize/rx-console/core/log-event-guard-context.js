import { LogEventGuard } from './log-event-guard';
/**
 * Base class for entities that want to be able to filter log event instances.
 */
export class LogEventGuardContext {
    constructor() {
        this.guard = new LogEventGuard();
    }
    /**
     * Returns true if the underling guard is set to any mode
     * other than BLOCK_ALL.
     */
    isEnabled() {
        return this.guard.mode !== 2 /* LogEventGuardMode.BLOCK_ALL */;
    }
    /**
     * Returns true if the underlying guard accepts the given event
     * based on its current mode and custom filter function (if any).
     */
    accepts(ev) {
        return this.guard.accepts(ev);
    }
    /**
     * Customize which log events should be ignored by this instance.
     * If the given predicate returns truthy, the event will be passed along
     * to any registered listeners or transports; otherwise it will be suppressed.
     *
     * Pass `null` to reset the filter.
     */
    setFilter(value) {
        this.guard.setFilter(value);
        return this;
    }
    /**
     * Set the enabled state of this instance, regarding whether or not it will
     * emit any log events. When true, emits events as normal; when false,
     * suppresses all events.
     *
     * The main benefit of this is to temorarily suppress all events on this
     * instance, while keeping the currently set filter in-tact.
     *
     * e.g. If this instance has a custom filter set, and then is disabled,
     * when this is re-enabled later it will continue using the custom filter.
     */
    setEnabled(enabled) {
        if (enabled !== this.isEnabled()) {
            const mode = enabled ? 0 /* LogEventGuardMode.DEFAULT */ : 2 /* LogEventGuardMode.BLOCK_ALL */;
            this.guard.setMode(mode);
        }
        return this;
    }
}
