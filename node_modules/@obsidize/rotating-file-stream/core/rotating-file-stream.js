import { __awaiter } from "tslib";
/**
 * Core interface for publishing file data across multiple files seamlessly.
 * When a file reaches a certain size threshold, incoming data will automatically be
 * routed to the next available file in the queue.
 *
 * When all files in the queue are full, the stream will wrap around to the oldest
 * file and overwrite it with new data.
 *
 * The methodology of how and when the rotation mechanism happens will be
 * fully customizable through the options given in the constructor.
 */
export class RotatingFileStream {
    constructor(options) {
        this.options = options;
    }
    write(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const entry = yield this.loadTargetEntry();
            const shouldOverwrite = this.isEntryFull(entry);
            yield entry.write(data, shouldOverwrite);
        });
    }
    refreshAllEntries() {
        return __awaiter(this, void 0, void 0, function* () {
            const { files } = this.options;
            for (const file of files) {
                yield file.refresh();
            }
            return files;
        });
    }
    isEntryFull(entry) {
        return entry.getSize() >= this.options.maxFileSize;
    }
    loadTargetEntry() {
        return __awaiter(this, void 0, void 0, function* () {
            const entries = yield this.refreshAllEntries();
            let target = entries[0];
            for (let i = 1; i < entries.length; i++) {
                target = this.chooseOptimalTarget(target, entries[i]);
            }
            return target;
        });
    }
    chooseOptimalTarget(a, b) {
        // A still has room to append data
        if (!this.isEntryFull(a)) {
            return a;
        }
        // A is full, but B still has room to append data
        if (!this.isEntryFull(b)) {
            return b;
        }
        // Overwrite B when both are full and A was more recently modified 
        // (B is older and should be overwritten in rotation)
        if (a.getLastModificationTime() > b.getLastModificationTime()) {
            return b;
        }
        // Both are full and somehow equally old... so default to using A
        return a;
    }
}
