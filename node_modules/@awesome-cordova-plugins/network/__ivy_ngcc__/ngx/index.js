import { __extends } from "tslib";
import { Injectable } from '@angular/core';
import { AwesomeCordovaNativePlugin, cordova, checkAvailability, cordovaPropertyGet, cordovaPropertySet } from '@awesome-cordova-plugins/core';
import { Observable, merge } from 'rxjs';
import { mapTo } from 'rxjs/operators';
import * as ɵngcc0 from '@angular/core';
export var Connection;
(function (Connection) {
    Connection["UNKNOWN"] = "unknown";
    Connection["ETHERNET"] = "ethernet";
    Connection["WIFI"] = "wifi";
    Connection["CELL_2G"] = "2g";
    Connection["CELL_3G"] = "3g";
    Connection["CELL_4G"] = "4g";
    Connection["CELL"] = "cellular";
    Connection["NONE"] = "none";
})(Connection || (Connection = {}));
var Network = /** @class */ (function (_super) {
    __extends(Network, _super);
    function Network() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Constants for possible connection types
         */
        _this.Connection = {
            UNKNOWN: 'unknown',
            ETHERNET: 'ethernet',
            WIFI: 'wifi',
            CELL_2G: '2g',
            CELL_3G: '3g',
            CELL_4G: '4g',
            CELL: 'cellular',
            NONE: 'none',
        };
        return _this;
    }
    Network.prototype.onChange = function () {
        var _this = this;
        return (function () {
            if (checkAvailability(_this) === true) {
                return merge(_this.onConnect().pipe(mapTo('connected')), _this.onDisconnect().pipe(mapTo('disconnected')));
            }
        })();
    };
    Network.prototype.onDisconnect = function () { return cordova(this, "onDisconnect", { "eventObservable": true, "event": "offline", "element": "document" }, arguments); };
    Network.prototype.onConnect = function () { return cordova(this, "onConnect", { "eventObservable": true, "event": "online", "element": "document" }, arguments); };
    Object.defineProperty(Network.prototype, "type", {
        get: function () { return cordovaPropertyGet(this, "type"); },
        set: function (value) { cordovaPropertySet(this, "type", value); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Network.prototype, "downlinkMax", {
        get: function () { return cordovaPropertyGet(this, "downlinkMax"); },
        set: function (value) { cordovaPropertySet(this, "downlinkMax", value); },
        enumerable: false,
        configurable: true
    });
    Network.pluginName = "Network";
    Network.plugin = "cordova-plugin-network-information";
    Network.pluginRef = "navigator.connection";
    Network.repo = "https://github.com/apache/cordova-plugin-network-information";
    Network.platforms = ["Amazon Fire OS", "Android", "Browser", "iOS", "Windows"];
Network.ɵfac = /*@__PURE__*/ function () { var ɵNetwork_BaseFactory; return function Network_Factory(t) { return (ɵNetwork_BaseFactory || (ɵNetwork_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(Network)))(t || Network); }; }();
Network.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: Network, factory: function (t) { return Network.ɵfac(t); } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Network, [{
        type: Injectable
    }], null, null); })();
    return Network;
}(AwesomeCordovaNativePlugin));
export { Network };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9AYXdlc29tZS1jb3Jkb3ZhLXBsdWdpbnMvcGx1Z2lucy9uZXR3b3JrL25neC9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLGtHQU1OLE1BQU0sK0JBQStCLENBQUM7QUFDdkMsT0FBTyxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDekMsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLGdCQUFnQixDQUFDOztBQUl2QyxNQUFNLENBQU4sSUFBWSxVQVNYO0FBVEQsV0FBWSxVQUFVO0FBQ3JCLElBQUMsaUNBQW1CLENBQUE7QUFBQyxJQUNwQixtQ0FBcUIsQ0FBQTtBQUFDLElBQ3RCLDJCQUFhLENBQUE7QUFBQyxJQUNkLDRCQUFjLENBQUE7QUFBQyxJQUNmLDRCQUFjLENBQUE7QUFBQyxJQUNmLDRCQUFjLENBQUE7QUFBQyxJQUNmLCtCQUFpQixDQUFBO0FBQUMsSUFDbEIsMkJBQWEsQ0FBQTtBQUNmLENBQUMsRUFUVyxVQUFVLEtBQVYsVUFBVSxRQVNyQjtBQUNEO0FBRzJCLElBZ0RFLDJCQUEwQjtBQUFDO0FBRXZDO0FBSWQsUUFMRDtBQUNGO0FBRUEsV0FESztBQUNMLFFBQUUsZ0JBQVUsR0FBRztBQUNmLFlBQUksT0FBTyxFQUFFLFNBQVM7QUFDdEIsWUFBSSxRQUFRLEVBQUUsVUFBVTtBQUN4QixZQUFJLElBQUksRUFBRSxNQUFNO0FBQ2hCLFlBQUksT0FBTyxFQUFFLElBQUk7QUFDakIsWUFBSSxPQUFPLEVBQUUsSUFBSTtBQUNqQixZQUFJLE9BQU8sRUFBRSxJQUFJO0FBQ2pCLFlBQUksSUFBSSxFQUFFLFVBQVU7QUFDcEIsWUFBSSxJQUFJLEVBQUUsTUFBTTtBQUNoQixTQUFHLENBQUM7QUFDSjtBQUVlO0FBQ2YsSUFrQkUsMEJBQVE7QUFBaUI7QUFBMEI7QUFFN0MsbURBRitDO0FBQ3ZELGdCQUFJLE9BQU8sS0FBSyxDQUNWLEtBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDLEVBQ3pDLEtBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQyxDQUErQixDQUM5RSxDQUFDO0FBQ04sYUFBRztBQUNIO0FBRU87QUFBTyxJQVNaLDhCQUFZO0FBTytCLElBTzNDLDJCQUFTO0FBSXNGLDBCQWxENUUseUJBQUk7QUFBSTtBQU83QjtBQUcyQjtBQUEyQjtBQUVqQztBQUFRLDBCQUxSLGdDQUFXO0FBQUk7QUFLL0I7QUFHRTtBQUEyQjtBQUM5QjtBQUFRO0FBQ2tCO0FBQ1U7QUFDcEM7QUFNYTsyQ0E5Q2hCLFVBQVU7Ozs7MEJBQ0w7QUFBQyxrQkExRVA7QUFBRSxFQTBFMkIsMEJBQTBCO0FBQ3RELFNBRFksT0FBTztBQUFJIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgQ29yZG92YSxcbiAgQ29yZG92YUNoZWNrLFxuICBDb3Jkb3ZhUHJvcGVydHksXG4gIEF3ZXNvbWVDb3Jkb3ZhTmF0aXZlUGx1Z2luLFxuICBQbHVnaW4sXG59IGZyb20gJ0Bhd2Vzb21lLWNvcmRvdmEtcGx1Z2lucy9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIG1lcmdlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXBUbyB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuZGVjbGFyZSBjb25zdCBuYXZpZ2F0b3I6IGFueTtcblxuZXhwb3J0IGVudW0gQ29ubmVjdGlvbiB7XG4gIFVOS05PV04gPSAndW5rbm93bicsXG4gIEVUSEVSTkVUID0gJ2V0aGVybmV0JyxcbiAgV0lGSSA9ICd3aWZpJyxcbiAgQ0VMTF8yRyA9ICcyZycsXG4gIENFTExfM0cgPSAnM2cnLFxuICBDRUxMXzRHID0gJzRnJyxcbiAgQ0VMTCA9ICdjZWxsdWxhcicsXG4gIE5PTkUgPSAnbm9uZScsXG59XG5cbi8qKlxuICogQG5hbWUgTmV0d29ya1xuICogQHByZW1pZXIgbmV0d29yay1pbmZvcm1hdGlvblxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXF1aXJlcyBDb3Jkb3ZhIHBsdWdpbjogY29yZG92YS1wbHVnaW4tbmV0d29yay1pbmZvcm1hdGlvbi4gRm9yIG1vcmUgaW5mbywgcGxlYXNlIHNlZSB0aGUgW05ldHdvcmsgcGx1Z2luIGRvY3NdKGh0dHBzOi8vZ2l0aHViLmNvbS9hcGFjaGUvY29yZG92YS1wbHVnaW4tbmV0d29yay1pbmZvcm1hdGlvbikuXG4gKiBAdXNhZ2VcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IE5ldHdvcmsgfSBmcm9tICdAYXdlc29tZS1jb3Jkb3ZhLXBsdWdpbnMvbmV0d29yay9uZ3gnO1xuICpcbiAqIGNvbnN0cnVjdG9yKHByaXZhdGUgbmV0d29yazogTmV0d29yaykgeyB9XG4gKlxuICogLi4uXG4gKlxuICogLy8gd2F0Y2ggbmV0d29yayBmb3IgYSBkaXNjb25uZWN0aW9uXG4gKiBsZXQgZGlzY29ubmVjdFN1YnNjcmlwdGlvbiA9IHRoaXMubmV0d29yay5vbkRpc2Nvbm5lY3QoKS5zdWJzY3JpYmUoKCkgPT4ge1xuICogICBjb25zb2xlLmxvZygnbmV0d29yayB3YXMgZGlzY29ubmVjdGVkIDotKCcpO1xuICogfSk7XG4gKlxuICogLy8gc3RvcCBkaXNjb25uZWN0IHdhdGNoXG4gKiBkaXNjb25uZWN0U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gKlxuICpcbiAqIC8vIHdhdGNoIG5ldHdvcmsgZm9yIGEgY29ubmVjdGlvblxuICogbGV0IGNvbm5lY3RTdWJzY3JpcHRpb24gPSB0aGlzLm5ldHdvcmsub25Db25uZWN0KCkuc3Vic2NyaWJlKCgpID0+IHtcbiAqICAgY29uc29sZS5sb2coJ25ldHdvcmsgY29ubmVjdGVkIScpO1xuICogICAvLyBXZSBqdXN0IGdvdCBhIGNvbm5lY3Rpb24gYnV0IHdlIG5lZWQgdG8gd2FpdCBicmllZmx5XG4gKiAgICAvLyBiZWZvcmUgd2UgZGV0ZXJtaW5lIHRoZSBjb25uZWN0aW9uIHR5cGUuIE1pZ2h0IG5lZWQgdG8gd2FpdC5cbiAqICAgLy8gcHJpb3IgdG8gZG9pbmcgYW55IGFwaSByZXF1ZXN0cyBhcyB3ZWxsLlxuICogICBzZXRUaW1lb3V0KCgpID0+IHtcbiAqICAgICBpZiAodGhpcy5uZXR3b3JrLnR5cGUgPT09ICd3aWZpJykge1xuICogICAgICAgY29uc29sZS5sb2coJ3dlIGdvdCBhIHdpZmkgY29ubmVjdGlvbiwgd29vaG9vIScpO1xuICogICAgIH1cbiAqICAgfSwgMzAwMCk7XG4gKiB9KTtcbiAqXG4gKiAvLyBzdG9wIGNvbm5lY3Qgd2F0Y2hcbiAqIGNvbm5lY3RTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAqXG4gKiBgYGBcbiAqIEBhZHZhbmNlZFxuICogVGhlIGB0eXBlYCBwcm9wZXJ0eSB3aWxsIHJldHVybiBvbmUgb2YgdGhlIGZvbGxvd2luZyBjb25uZWN0aW9uIHR5cGVzOiBgdW5rbm93bmAsIGBldGhlcm5ldGAsIGB3aWZpYCwgYDJnYCwgYDNnYCwgYDRnYCwgYGNlbGx1bGFyYCwgYG5vbmVgXG4gKi9cbkBQbHVnaW4oe1xuICBwbHVnaW5OYW1lOiAnTmV0d29yaycsXG4gIHBsdWdpbjogJ2NvcmRvdmEtcGx1Z2luLW5ldHdvcmstaW5mb3JtYXRpb24nLFxuICBwbHVnaW5SZWY6ICduYXZpZ2F0b3IuY29ubmVjdGlvbicsXG4gIHJlcG86ICdodHRwczovL2dpdGh1Yi5jb20vYXBhY2hlL2NvcmRvdmEtcGx1Z2luLW5ldHdvcmstaW5mb3JtYXRpb24nLFxuICBwbGF0Zm9ybXM6IFsnQW1hem9uIEZpcmUgT1MnLCAnQW5kcm9pZCcsICdCcm93c2VyJywgJ2lPUycsICdXaW5kb3dzJ10sXG59KVxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE5ldHdvcmsgZXh0ZW5kcyBBd2Vzb21lQ29yZG92YU5hdGl2ZVBsdWdpbiB7XG4gIC8qKlxuICAgKiBDb25zdGFudHMgZm9yIHBvc3NpYmxlIGNvbm5lY3Rpb24gdHlwZXNcbiAgICovXG4gIENvbm5lY3Rpb24gPSB7XG4gICAgVU5LTk9XTjogJ3Vua25vd24nLFxuICAgIEVUSEVSTkVUOiAnZXRoZXJuZXQnLFxuICAgIFdJRkk6ICd3aWZpJyxcbiAgICBDRUxMXzJHOiAnMmcnLFxuICAgIENFTExfM0c6ICczZycsXG4gICAgQ0VMTF80RzogJzRnJyxcbiAgICBDRUxMOiAnY2VsbHVsYXInLFxuICAgIE5PTkU6ICdub25lJyxcbiAgfTtcblxuICAvKipcbiAgICogQ29ubmVjdGlvbiB0eXBlXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBAQ29yZG92YVByb3BlcnR5KCkgdHlwZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBEb3dubGluayBNYXggU3BlZWRcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIEBDb3Jkb3ZhUHJvcGVydHkoKSBkb3dubGlua01heDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgdG8gd2F0Y2ggY29ubmVjdGlvbiBjaGFuZ2VzXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlPCdjb25uZWN0ZWQnIHwgJ2Rpc2Nvbm5lY3RlZCc+fVxuICAgKi9cbiAgQENvcmRvdmFDaGVjaygpXG4gIG9uQ2hhbmdlKCk6IE9ic2VydmFibGU8J2Nvbm5lY3RlZCcgfCAnZGlzY29ubmVjdGVkJz4ge1xuICAgIHJldHVybiBtZXJnZShcbiAgICAgIHRoaXMub25Db25uZWN0KCkucGlwZShtYXBUbygnY29ubmVjdGVkJykpLFxuICAgICAgdGhpcy5vbkRpc2Nvbm5lY3QoKS5waXBlKG1hcFRvKCdkaXNjb25uZWN0ZWQnKSkgYXMgT2JzZXJ2YWJsZTwnZGlzY29ubmVjdGVkJz5cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBub3RpZmllZCB3aGVuIHRoZSBkZXZpY2UgZ29lcyBvZmZsaW5lXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlPGFueT59IFJldHVybnMgYW4gb2JzZXJ2YWJsZS5cbiAgICovXG4gIEBDb3Jkb3ZhKHtcbiAgICBldmVudE9ic2VydmFibGU6IHRydWUsXG4gICAgZXZlbnQ6ICdvZmZsaW5lJyxcbiAgICBlbGVtZW50OiBkb2N1bWVudCxcbiAgfSlcbiAgb25EaXNjb25uZWN0KCk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBub3RpZmllZCB3aGVuIHRoZSBkZXZpY2UgZ29lcyBvbmxpbmVcbiAgICpcbiAgICogQHJldHVybnMge09ic2VydmFibGU8YW55Pn0gUmV0dXJucyBhbiBvYnNlcnZhYmxlLlxuICAgKi9cbiAgQENvcmRvdmEoe1xuICAgIGV2ZW50T2JzZXJ2YWJsZTogdHJ1ZSxcbiAgICBldmVudDogJ29ubGluZScsXG4gICAgZWxlbWVudDogZG9jdW1lbnQsXG4gIH0pXG4gIG9uQ29ubmVjdCgpOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIHJldHVybjtcbiAgfVxufVxuIl19